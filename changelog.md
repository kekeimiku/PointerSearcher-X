# v0.1.0-beta1

## 变化

内部大量改进 性能大幅增强，减少内存占用，最大depth以及offset提高到 Max_u64

支持直接扫描dump文件

# v0.0.7

## 变化

现在最大 depth 提高到 13， 最大 offset 提高到 N+N <= 4096

现在使用二进制格式储存扫描结果

扫描成本是 O(NN*D) (D:Max Depth,N:Offset Num)

本次更改稍微增加了较低情况下的开销，改善了较高情况下 (D>9 or N>1024) 的性能。

虽然改善了较高情况下的性能，但依然推荐使用较低且合理的 Depth or Offset ，除非你给定了起始地址

添加了几个工具

`ups-get` 用于验证整条路径所指向的地址 `ups-get $(pgrep hello) "libhello.dylib+0x804c0->0->1808->552->-144"`

`ups-diff` 用于对比两个结果 `ups-diff hello-600001008050.bin hello-600001c0c050.bin`

`ups-show` 用于查看结果 `ups-show xxx.bin`

# v0.0.6

添加了自动对比两次扫描结果的工具

## 变化

1. 现在不再将每条目标地址路径都写入同一个文件

改为类似 `app-123abc.txt` `app-456abc.txt` 分别储存

2. 现在每条路径结尾不再储存目标地址，直接放在文件名里面

以前: `abc.dylib+0x28->0->0->0=>0x132704080`

现在: filename `app-132704080.txt` 内容 `abc.dylib+0x28->0->0->0`

3. 性能提升

# v0.0.5

内部重构，为跨平台做准备

添加linux支持

# v0.0.5-beta3

## 变化

1. 输出的结果排除了从堆栈上开始的路径。

2. 更改了输出结果为更加常见的格式

- 以前是: `0x789123->0->0->0=>0x132704080`

以前用户不需要关心哪个模块，只需要关心aslr，但是linux似乎和mac机制不同，这个方法似乎无法在linux上找到等效实现。为了以后跨平台做准备，使用了更通用的扫描方法。

- 现在: `abc.dylib+0x28->0->0->0=>0x132704080`

明确指出了使用哪个模块，不再关心aslr。

这不仅是输出格式的改进，内部扫描逻辑也不再关心aslr，但降低了性能。

以后也可能会改回去或者使用其它方法。

# v0.0.5-beta2

## 变化

1. 更改了输出结果

```
                    变化在这里-> v
以前：0x105705c90->0->8->16->64->6000026ac5e0

                    变化在这里-> v
现在: 0x105705c90->0->8->16->64=>6000026ac5e0
```
2. 现在扫描结果会直接写入文件 `ups-XXX-name.txt`

3. 扫描速度提升，内存占用减少

4. 修复某些罕见情况下扫描动态库出错的问题。

5. 修复 `dyld_all_image_infos` 没有正确对齐（以前似乎只是碰巧可以正常工作。。。）。

6. 不再全手动维护ffi，大部分改为bindgen并手动修改，更新到最新的MacOSX13.1。

7. 添加了四个测试文件用于方便验证扫描结果。

# v0.0.5-beta1

优化扫描规则，现在可以正确扫描动态库 [#5](https://github.com/kekeimiku/ups/issues/5)

格式化输出扫描结果的一些微小性能提升

# v0.0.4

格式化输出扫描结果的一些微小性能提升

# v0.0.4-beta2

限制了最大offset `-2048:2048`

每次储存offset减少到两个字节（以前为八个字节）

# v0.0.4-beta

## 性能提升

路径中不再储存指针值，这减少了储存扫描结果的压力

以前: `0x105705c90 + 0 > 0x600001460ae0 + 8 > 0x60000170c560 + 16 > 0x60000170c5a0 + 64 > 6000026ac5e0`。

现在: `0x105705c90 ->0->8->16->64->6000026ac5e0`。

限制了最大深度为11，以前几乎没有限制（uint64最大值）。

以相当微小的代价，将一些数据储存在栈上，避免频繁的堆分配。

## 其它

由于 ups 流式扫描内存，并且使用提前分配的方式，使得 `扫描过程中` 获得一些性能提升，以前默认的`buffer`大小为`1MB`，最后一块内存会被直接`抛弃`或`填充0`(默认假设大概率不会在最后一块中获得什么)，但是对于一些小程序可能会丢失重要信息，所以现在`buffer`默认为`64kb`，也许以后有更好的办法处理这个。

# v0.0.3

## 新功能

支持扫描多个目标地址！

但这会降低扫描速度

命令格式 

多个地址可以用 '-' 分隔

`ups -p <pid> -t 0x111-0x222`

如果多个地址中有在同一条路径里面的则只输出最远距离的同一条路径

例如 `ups -p 123 -t 0x600000154740-0x600000ccc7c0 -o 0:32`

`0x600000ccc7c0` 是最远的 并且路径中会包含 `0x600000154740` 则输出

`... > 0x600000154740 + 16 > 0x600000154780 + 32 > 0x600000ccc7c0`

如果它们互不重叠 例如 `ups -p 123 -t 0x1467040c0-0x146704120 -o 0:32`

`0x1467040c0` 和 `0x146704120` 它们的路径互不重叠，则输出互相独立的路径

`... + 0 > 0x145be80d0 + 0 > 0x1467040c0`

`... + 0 > 0x145be8130 + 0 > 0x146704120`

## 其它

优化文件大小

# v0.0.2

## 新功能

支持扫描以指定地址开始的路径！

这会提升扫描速度

命令格式

`ups -p <pid> -t <target> -s 0x111`

多个地址可以用 '-' 分隔

`ups -p <pid> -t <target> -s 0x111-0x222-0x333`

## 其它

优化一些错误处理

# v0.0.1

[#3](https://github.com/kekeimiku/ups/issues/3) 修复 `--offset -32:32` 负偏移参数错误解析

## 其它

优化程序大小，略微优化参数解析和错误处理

# v0.0.1-beta

初个版本